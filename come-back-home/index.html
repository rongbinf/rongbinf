<!DOCTYPE html>
<html lang="zh-Hans" dir="ltr">
<head>
  <title>简化，回归 - Rongbin&#39;s Blog</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<meta name="description"
    content="由于常年固定使用某些邮箱地址注册网络帐户，以及邮件订阅设置的混乱，导致我不得不腾出一个下午的时间清理这些邮件，而这些邮件大多是注册帐户时发来的验证、社交网络的提醒、过去订阅的博客资讯和提醒你时常回看的应用广告。于是我把现在已经不常用的、能合并或替代的各类帐号注销，一是方便管理，二是删除自己曾经留下的网络痕迹。
进行邮件清理后，我试着对自己的信息源进行管理。我把自己获取信息的途径分为三种：信息聚合类应用、订阅邮件和 RSS 订阅源。信息聚合类应用包括 Medium 、微信订阅号和知乎专栏这种长文聚合、Quora 的问答、端传媒等新闻资讯应用。在这之中比较难管理的是微信订阅号。有部分作者有个人博客的，我都将其收进 Reeder 用 RSS 订阅的形式阅读，但部分只有个人公众号的作者，需要进一步对内容作出筛选。使用邮件订阅或 RSS 的形式阅读，最大的优点是即时离线存档，不仅便于日后阅读和搜索归档，也避免了一些敏感文章被封锁的风险。
由此出发，其实最终需要花费心思的是对信息源的筛选和整合。如何最大限度地利用网络信息帮助自己成长？
Leo Babauta 在他的著名博客 zen habits 中提到了一个很有趣的观点。他认为生活的简化是一种循环的模式：
The Simplicity Cycle goes something like this (it’s a little different each time):
Inspiration phase: You find something that sparks an interest, and you start exploring it (reading about a new topic, diving into learning a new subject, exploring a new activity or hobby, creating a new project or venture, etc. ">
<link rel="canonical" href="https://fanrongbin.com/come-back-home/" />






      <link rel="stylesheet" href="/css/main.min.c9cb03468dcf536d77774c9e6bb9004b3b330e5b444311390443afb6e4d0fc80.css" integrity="sha256-ycsDRo3PU213d0yea7kASzszDltEQxE5BEOvtuTQ/IA=" crossorigin="anonymous">

<link rel="stylesheet" href="/han.min.css" type="text/css">

      <script src="/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js" integrity="sha256-I80MfYNyY7nq65buLZzPopadqj&#43;gD6HB/ocBqbhyUaE=" crossorigin="anonymous"></script>



</head>
<body class="han-init-context">
  <section class="navbar">
    <span class="header-name"><a href="/" class="header-link">Rongbin FAN</a> / <a href="/posts" class="header-link">Blog</a>
<br><a href="/links" class="header-link header-guestbook">◩ Guestbook</a>
</span>


  </section>
    

<section class="content-header">

  <div class="top-scroll-bar"></div>
<div class="addn visible">
<div id="show-hypo" class="header-button no-select"><a onclick="showHypo()" style="color:var(--textcolor);text-decoration:none;border:none;">Hypothes.is</a></div>
<div id="contents-fixed" class="header-button no-select"><a onclick="toggleContents()" style="color:var(--textcolor);text-decoration:none;border:none;">Contents</a></div>
</div>
<div id="contents-toc" class="no-select">
    <nav id="TableOfContents"></nav>
</div>

  <div id="single-header">
    <h1 class="content-h1">简化，回归</h1>
    
    
      <p class="content-time"><time datetime="2018-08-28T00:00:00&#43;00:00">28 August 2018</time></p>
    
  </div>

</section>

<style>
  div.color {
    background: linear-gradient(var(--textcolor) 0,transparent 25%);
    opacity: .5;
  }
</style>


    <div class="color"></div>
  <main>
    

<p>由于常年固定使用某些邮箱地址注册网络帐户，以及邮件订阅设置的混乱，导致我不得不腾出一个下午的时间清理这些邮件，而这些邮件大多是注册帐户时发来的验证、社交网络的提醒、过去订阅的博客资讯和提醒你时常回看的应用广告。于是我把现在已经不常用的、能合并或替代的各类帐号注销，一是方便管理，二是删除自己曾经留下的网络痕迹。</p>
<p>进行邮件清理后，我试着对自己的信息源进行管理。我把自己获取信息的途径分为三种：信息聚合类应用、订阅邮件和 RSS 订阅源。信息聚合类应用包括 Medium 、微信订阅号和知乎专栏这种长文聚合、Quora 的问答、端传媒等新闻资讯应用。在这之中比较难管理的是微信订阅号。有部分作者有个人博客的，我都将其收进 Reeder 用 RSS 订阅的形式阅读，但部分只有个人公众号的作者，需要进一步对内容作出筛选。使用邮件订阅或 RSS 的形式阅读，最大的优点是即时离线存档，不仅便于日后阅读和搜索归档，也避免了一些敏感文章被封锁的风险。</p>
<p>由此出发，其实最终需要花费心思的是对信息源的筛选和整合。如何最大限度地利用网络信息帮助自己成长？</p>
<p>Leo Babauta 在他的著名博客 <a href="https://zenhabits.net/cycle/">zen habits</a> 中提到了一个很有趣的观点。他认为生活的简化是一种循环的模式：</p>
<blockquote>
<p>The Simplicity Cycle goes something like this (it’s a little different each time):</p>
<ol>
<li><strong>Inspiration phase</strong>: You find something that sparks an interest, and you start exploring it (reading about a new topic, diving into learning a new subject, exploring a new activity or hobby, creating a new project or venture, etc.). This is the inspiration phase.</li>
<li><strong>Addition phase</strong>: This leads you to more complexity, as you explore, buy things, read more and more, find new inspirations and ideas. This is the addition phase.</li>
<li><strong>Contemplation phase</strong>: At some point, you might pause to consider the bigger picture of what you’re doing. Is this the best way? Is this really important? If it is, what’s the most essential part of it? Can you pare down? Many people skip this phase (and the next) and just keep doing the first two phases.</li>
<li><strong>Paring Down phase</strong>: If you decided that you want to pare down, this is where you start to let go of things. You figure out what’s essential to what you have been doing and learning, and if you don’t scrap the entire thing completely (which can happen), you might just keep a few key things. For example, if you start learning about chess, you might buy a set (or two) and a bunch of books and apps and go on a bunch of websites. But in the paring down phase, you might decide that chess isn’t important enough to keep in your life, or if it is, you only need one chess set, two really key books, and one website or app. The rest you let go of. Again, many people skip this step.</li>
</ol>
</blockquote>
<p>它分成四个阶段：探索阶段、深入阶段、思考阶段和削减阶段。在前两个阶段，你大量的获取和收集感兴趣的信息，并且进行了一定的拓宽。例如在偶然一则热带风暴的新闻中，记者提到了风眼这个名词，由此你上网查找资料以了解这个天气的成因、结构等等。单个天气系统不足以满足好奇心，你转而寻找能够集合这类资讯和推送给你的信息源，久而久之，你可能就拥有了一定数量该领域的信息源。这两个阶段是你好奇心和能力拓展的主要阶段，但在前两个阶段我们做的工作可能会比较盲目，你可能不常会回看这些订阅关注的信息源，而这些信息源在之后也许会因为各种各样的原因停用，或是转为其他内容。为了让自己获取的信息更有价值、阅读更高效，我们要做的并非一开始就抑制自己收集信息的想法，而是收集之后再简化。就像 GTD 中 Inbox 的概念一样，在这里我们也需要一个无形的 Inbox 把它们收集起来。</p>
<p>思考阶段则是你对获得的这些信息的分类筛选。这些信息我真的需要吗？我对这个真的感兴趣吗？例如你只是想知道热带风暴的成因和防灾的方法，而不想再去了解它是怎么被预报之类的，你很自然地开始了思考阶段并作出了判断——针对性的收集信息。并且开始削减阶段——削减之前收集到的不感兴趣的内容。</p>
<p>上述模式，核心是给我们营造了「回归」的条件，也就是思考我们实际的需求是什么，回归到需求上来。任何事情都需要一个目的或需求以驱使我们行动，而回归需求给予我们动力，并且避免了不必要事情的干扰，最终达到趋于平静的一种状态。</p>



  </main>
  
    

<div class="footer-nav">

  <div class="previous-post" style="display:inline-block;">
    
    <a class="no-external" href="https://fanrongbin.com/hexo-github-pages-cloudflare/"><span class="arrow">←</span> Hexo + GitHub Pages + Cloudflare</a>
    
  </div>

  



  <div class="next-post" style="display:inline-block;float:right;">
    
    <a class="no-external" href="https://fanrongbin.com/339/">白色的空间 <span
        class="arrow">→</span></a>
    
  </div>

</div>


  
  <footer class="opacity-6">
    <p><a href="/colophon">Colophon</a> | <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC BY-SA 4.0</a></p><p>© Rongbin FAN</p>
  </footer>
</body>
<script src="/han.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        if (document.querySelector('.content-header')) {
            document.getElementById('show-hypo').style.display = 'flex';
        }

        applyBreakAllClass();

        handleScrollEvents();

        initializeTOCFeatures();
    });

    window.addEventListener('scroll', throttle(handleScrollEvents, 250), false);

    window.addEventListener('resize', applyBreakAllClass);

    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function () {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function () {
                    if ((Date.now() - lastRan) >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        }
    }

    function showHypo() {
        var existingScript = document.getElementById('hypothes-script');
        var button = document.querySelector('#show-hypo a');

        if (!existingScript) {
            button.textContent = 'Loading';

            var script = document.createElement('script');
            script.id = 'hypothes-script';
            script.src = 'https://hypothes.is/embed.js';

            script.onload = () => {
                button.textContent = 'Hypothes.is';
            };

            script.onerror = () => {
                button.style.color = 'red';
                button.textContent = 'Failed';
            };

            document.body.appendChild(script);
        } else {
            toggleHypothesisElementsVisibility();
            button.style.color = 'initial';
        }
    }

    function toggleHypothesisElementsVisibility() {
        const elementsToToggle = [
            'hypothesis-sidebar',
            'hypothesis-notebook',
            'hypothesis-profile',
            'hypothesis-adder',
            'hypothesis-highlight-cluster-toolbar'
        ];

        elementsToToggle.forEach(function (element) {
            var el = document.querySelector(element);
            if (el) {
                if (el.style.display === 'none') {
                    el.style.display = '';
                } else {
                    el.style.display = 'none';
                }
            }
        });
    }

    function applyBreakAllClass() {
        var screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

        if (screenWidth <= 960) {
            var codeElements = document.querySelectorAll('code');

            codeElements.forEach(function (element) {
                if (element.textContent.length > 10) {
                    element.classList.add('break-all');
                }
            });
        }
    }

    function handleScrollEvents() {
        var lastScrollTop = 0;
        var addnDiv = document.querySelector('.addn');
        var topScrollBar = document.querySelector('.top-scroll-bar');

        window.addEventListener('scroll', function () {
            var currentScroll = window.pageYOffset || document.documentElement.scrollTop;

            if (topScrollBar) {
                var scrollPercent = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
                topScrollBar.style.width = scrollPercent + '%';
                topScrollBar.style.display = 'block';
            }

            if (addnDiv) {
                if (currentScroll > lastScrollTop && currentScroll > 50) {
                    addnDiv.classList.remove('visible');
                } else {
                    addnDiv.classList.add('visible');
                }
            }

            lastScrollTop = currentScroll <= 0 ? 0 : currentScroll;
        }, false);
    }


    function initializeTOCFeatures() {
        const headers = document.querySelectorAll('h2, h3');
        const contentsFixedDiv = document.getElementById('contents-fixed');
        const tocContainer = document.getElementById('contents-toc');

        if (contentsFixedDiv) {
            const toggleTOC = () => {
                const isDisplayed = window.getComputedStyle(tocContainer).display !== 'none';
                tocContainer.style.display = isDisplayed ? 'none' : 'flex';

                if (tocContainer.style.display === 'flex') {
                    initializeTOCFeatures();
                }
            };

            const highlightAppropriateHeader = () => {
                let highlighted = false;
                let lastPassedHeader = null;

                headers.forEach(header => {
                    const link = document.querySelector(`nav#TableOfContents a[href="#${header.id}"]`);
                    const bounding = header.getBoundingClientRect();

                    if (bounding.top >= 0 && bounding.bottom <= window.innerHeight && !highlighted) {
                        link.classList.add('toc-highlight');
                        highlighted = true;
                    } else {
                        link.classList.remove('toc-highlight');
                    }

                    if (bounding.top < 0) {
                        lastPassedHeader = header;
                    }
                });

                if (!highlighted && lastPassedHeader) {
                    const link = document.querySelector(`nav#TableOfContents a[href="#${lastPassedHeader.id}"]`);
                    link.classList.add('toc-highlight');
                }
            };

            const throttledHighlight = throttle(highlightAppropriateHeader, 250);

            if (!tocContainer.dataset.initialized) {
                window.addEventListener('scroll', throttledHighlight);
                tocContainer.dataset.initialized = 'true';
            }

            document.addEventListener('click', (event) => {
                if (window.getComputedStyle(tocContainer).display !== 'none') {
                    tocContainer.style.display = 'none';
                }
            });

            tocContainer.addEventListener('click', (event) => {
                event.stopPropagation();
            });

            if (headers.length > 1) {
                contentsFixedDiv.style.display = 'flex';
                contentsFixedDiv.addEventListener('click', (event) => {
                    toggleTOC();
                    event.stopPropagation();
                });
            }
        }
    }
</script>


<script defer>
    document.addEventListener("DOMContentLoaded", function () {
        if (document.querySelectorAll('.sidenote-number').length >= 3 && window.innerWidth >= 1000) {
            var jQueryScript = document.createElement('script');
            jQueryScript.src = '/jquery-3.6.0.min.js';
            document.head.appendChild(jQueryScript);

            var sidenoteLines = document.querySelectorAll('.sidenote-line');
            sidenoteLines.forEach(function (line) {
                line.style.display = 'none';
            });

            var styleElement = document.createElement('style');
            styleElement.innerHTML = `
                .jsplumb-line {
                    opacity: 0.4;
                    z-index: -1;
                }
                li>span>.sidenote-box {
                    margin-left: -150%;
                }
            `;
            document.body.appendChild(styleElement);

            jQueryScript.onload = function () {
                var jsPlumbScript = document.createElement('script');
                jsPlumbScript.src = '/jsplumb.min.js';
                document.head.appendChild(jsPlumbScript);

                var jsPlumbCSS = document.createElement('link');
                jsPlumbCSS.href = '/jsplumbtoolkit-defaults.min.css';
                jsPlumbCSS.rel = 'stylesheet';
                document.head.appendChild(jsPlumbCSS);

                jsPlumbScript.onload = function () {

                    jQuery(document).ready(function () {
                        jsPlumb.importDefaults({
                            ConnectionsDetachable: false,
                            ReattachConnections: false,
                            Endpoint: "Blank", 
                            Connector: ["Straight"], 
                            PaintStyle: { stroke: "var(--text-color)", strokeWidth: 1 } 
                        });

                        function createConnections() {
                            jsPlumb.deleteEveryEndpoint(); 

                            jQuery('.sidenote-number').each(function () {
                                var sidenoteNumber = jQuery(this);
                                var sidenote = sidenoteNumber.find('.sidenote');

                                if (sidenote.length) {
                                    jsPlumb.connect({
                                        source: sidenoteNumber[0], 
                                        target: sidenote[0], 
                                        anchors: ["Center", "RightMiddle"], 
                                        cssClass: "jsplumb-line" 
                                    });
                                }
                            });
                        }

                        createConnections();

                        var resizeObserver = new ResizeObserver(function () {
                            createConnections(); 
                        });
                        resizeObserver.observe(document.body);

                    });
                };
            };
        }
    });
</script>

<script defer>
    window.onload = function () {
        document.addEventListener('touchstart', function (event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        });
        var lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            var now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        document.addEventListener('gesturestart', function (event) {
            event.preventDefault();
        });
    }
</script>


</html>
