<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Rongbin&#39;s Blog</title>
        <link>https://fanrongbin.com/posts/</link>
        <description>所有文章 | Rongbin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>fanrongbin0201@gmail.com (FAN Rongbin)</managingEditor>
            <webMaster>fanrongbin0201@gmail.com (FAN Rongbin)</webMaster><lastBuildDate>Fri, 28 Jan 2022 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://fanrongbin.com/posts/" rel="self" type="application/rss+xml" /><item>
    <title>糕点铺</title>
    <link>https://fanrongbin.com/bakery/</link>
    <pubDate>Fri, 28 Jan 2022 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/bakery/</guid>
    <description><![CDATA[<p>实习，住在团结湖，附近有一家糕点铺，晚上下班总要路过它。门口常常排着不长不短的队，几乎每次我都会装作心不在焉地往亮堂堂的橱窗一瞥，看看今天是绿豆酥饼卖得好，还是有新面包出炉。暗地里，我也决定找个时间也去排排队，买一盒试试看。今天是这个月最后一天班，坐上公交，想象那条刚认识没多久的路，先过路口，拐弯，直行，再走到对面，就能到糕点铺了。刷卡下车后我抬起头走路，可劲儿往对面瞧，却怎么也看不到那面墨绿色的招牌，一时以为是自己搞混了。怀疑的脚步越来越近，才发现关了灯、拉了铁门，赖以辨认的人群四散。今天已经是廿六了，后天回家，节后总要再过来。「所以总有机会吧」，这么想着，埋头往别处走了。</p>
<p>过去好像也是这么想的，以为是沙子，总在那里。以为像钱，攒起来当然就越攒越多。现在，恍惚间意识到自己再回来买酥饼的希望过分渺茫，被这样一份不可知不可触的酥饼想象击碎。我化成饮食大欲碎在地上，拼不成什么要「把握住机会」和「活在当下」的道理戒律，如此这般活，由着很多事情错过。</p>
]]></description>
</item><item>
    <title>半导体制作工序 &amp; 常见自动化软件模块梳理</title>
    <link>https://fanrongbin.com/semiconductor-procedure/</link>
    <pubDate>Thu, 27 Jan 2022 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/semiconductor-procedure/</guid>
    <description><![CDATA[<h2 id="半导体制作工序">半导体制作工序</h2>
<div class="mermaid" id="id-1"></div>
<p>参考自泛林集团科普文章：<a href="https://mp.weixin.qq.com/s?__biz=MzAwMjc5MzEyMA==&amp;mid=2653071344&amp;idx=1&amp;sn=5afa34f0343fe651c352fb1db90e4078&amp;chksm=81130c3fb66485295c95b0ebc4e5809c476ec251c6744f70ab90a44ca5a541c49441ccf3ba7b" target="_blank" rel="noopener noreffer">上篇</a>、<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1643333829&amp;ver=3585&amp;signature=6IlC6FZHoNgcGlFXYQmK00U0kkordqNzxXlGsuIi0sDeMcxJTa97kEv4PTwKJHS8sKsbm7TCcVpKdw5j-GkNlI6B8zB3SOQudBhCx*Q*bikIKvrrxLbecGT*jbEQgSM1&amp;new=1" target="_blank" rel="noopener noreffer">中篇</a>、<a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1643333829&amp;ver=3585&amp;signature=6IlC6FZHoNgcGlFXYQmK00U0kkordqNzxXlGsuIi0sBk7gTvrMy2efEIgPI-nvRVI4eGDu1UKmkBgwpES6RWt2*uv5-F6UX4qWh*0OTkISc77QkceIHU7l0o6yuay4gx&amp;new=1" target="_blank" rel="noopener noreffer">下篇</a>。英文对照请见<a href="#%e5%8d%8a%e5%af%bc%e4%bd%93%e5%88%b6%e4%bd%9c%e5%b7%a5%e5%ba%8f%e8%8b%b1%e6%96%87%e4%b8%8d%e5%ae%8c%e5%85%a8%e5%af%b9%e7%85%a7" rel="">文末</a>。你也可以<a href="https://www.tel.com/museum/exhibition/process/" target="_blank" rel="noopener noreffer">按此访问</a>东京威力科创制作的工序介绍。</p>
<p>半导体制作工序可分为前、后两道。前道包括 <code>1.晶圆加工</code> -&gt;<code> 7.测试</code>，后道包括<code>8.封装</code>及后期测试、其他组装、成品入库等。</p>
<p>常用英文名词：</p>
<ul>
<li>wafer：晶圆，硅晶片。分有 6、8、12 吋。</li>
<li>die：裸晶。wafer 上的小单位颗粒。合格的 die 在第八步封装时被切走为成品颗粒。</li>
<li>cell：比 die 更小的单位，如 IO 单元、电源管理单元。</li>
<li>cassette：晶盒。用来装 wafer。
<ul>
<li>FOUP（Front Opening Unified Pod）：前开晶片（统一）传送盒。一般用于厂内运输 wafer。</li>
<li>FOSB（Front Opening Shipping Box）：前开晶片运输盒。一般用于厂间成品或半成品运输。</li>
</ul>
</li>
<li>lot：批次。</li>
<li>recipe：制程配方。</li>
<li>equipment：机台，加工线上的所有设备。</li>
<li>fab（Semiconductor Fabrication Plant）：半导体制造厂。</li>
<li>WAT（Wafer Acceptance Test）：晶圆允收测试</li>
<li>UAT（User Acceptance Test）：用户允收测试</li>
<li>CP Yield（Circuit Probe Yield）：晶圆测试良率</li>
<li>RFP/RP（Request for Proposal）：需求建议书</li>
</ul>
<p>半导体行业有几种常见商业模式：</p>
<ul>
<li>Foundry：晶圆代工，负责晶圆制造、封装或测试中的一个或多个环节。如台积电。</li>
<li>IDM：包括 IC 设计、晶圆制造、封装测试等多个环节。如三星。</li>
<li>Fabless：只负责 IC 设计和销售，其他环节外包。如联发科。</li>
</ul>
<h2 id="半导体行业常用工业软件">半导体行业常用工业软件</h2>
<p>对于半导体厂内<em>自动化系统</em>常用工业软件，一般可分为四个层级：</p>
<h3 id="计划管理决策层">计划管理/决策层</h3>
<ul>
<li><strong><ruby>ERP<rt>企业资源计划</rt></ruby></strong>（Enterprise Resource Planning）</li>
<li><strong><ruby>SCM<rt>供应链管理</rt></ruby></strong>（Supply Chain Management）</li>
<li><strong><ruby>PLM<rt>产品生命周期管理</rt></ruby></strong>（Product Lifecycle Management）</li>
<li><strong><ruby>WMS<rt>仓储管理系统</rt></ruby></strong>（Warehouse Management System）</li>
<li><strong><ruby>OA<rt>办公自动化</rt></ruby></strong>、<strong><ruby>CRM<rt>消费者关系管理</rt></ruby></strong>、<strong><ruby>APS<rt>先进计划和排程</rt></ruby></strong>（Advanced Planning and Scheduling）等</li>
</ul>
<h3 id="计算机集成制造层">计算机集成制造层</h3>
<p><strong><ruby>CIM<rt>计算机集成制造</rt></ruby></strong>（Computer Integrated Manufacturing）</p>
<ul>
<li>制造管理和监测</li>
<li>制造执行
<ul>
<li><strong><ruby>MES<rt>制造执行系统</rt></ruby></strong>（Manufacturing Execution System）</li>
<li><strong><ruby>RTD<rt>实时派工系统</rt></ruby></strong>（Real-time Dispatch）</li>
<li><strong><ruby>SPC<rt>统计制程控制</rt></ruby></strong>（Statistical Process Control）</li>
</ul>
</li>
</ul>
<h3 id="一般控制层">一般控制层</h3>
<ul>
<li>自动化系统
<ul>
<li><strong><ruby>EAP<rt>设备自动化程序</rt></ruby></strong>（Equipment Automatic Programme)</li>
</ul>
</li>
<li><strong><ruby>EES<rt>设备工程系统</rt></ruby></strong>（Equipment Engineer System）
<ul>
<li><strong><ruby>APC<rt>先进过程控制</rt></ruby></strong>（Advanced Process Control）
<ul>
<li>一般会认定其包含 <strong><ruby>R2R<rt>批次控制</rt></ruby></strong>（Run-to-Run）、FDC、<strong><ruby>OEE<rt>整体设备效率</rt></ruby></strong>（Overall Equipment Efficiency），但包含关系和范围没有明显界定</li>
</ul>
</li>
<li><strong><ruby>FDC<rt>故障侦测与分类</rt></ruby></strong>（Fault Detection and Classification）</li>
<li><strong><ruby>PMS<rt>预防保养系统</rt></ruby></strong>（Preventive Maintenance System）</li>
<li><strong><ruby>YMS<rt>良率管理系统</rt></ruby></strong>（Yield Management System）</li>
<li><strong><ruby>TMS<rt>运输管理系统</rt></ruby></strong>（Transportation Management System）</li>
<li><strong><ruby>RMS<rt>Recipe/配方管理系统</rt></ruby></strong>（Recipe Management System）</li>
<li>与 <strong><ruby>AMHS<rt>自动物料搬送系统/天车</rt></ruby></strong>（Automatic Material Handling System）的配合</li>
</ul>
</li>
</ul>
<h3 id="现场设备层机台">现场设备层：机台</h3>
<ul>
<li><strong><ruby>PLC<rt>可编程逻辑控制器</rt></ruby></strong>（Programmable Logic Controller）</li>
<li>其他 censor 等</li>
</ul>
<hr>
<p>CIM 主体包括 <strong>MES</strong> 和 <strong>EAP</strong>。MES 负责车间生产管理和调度执行，实时监控生产过程并响应状态变化。EAP 对接 MES 和机台设备，负责信息传输、数据搜集、流程控制和异常捕捉。因而 APC、FDC、 PMS 等系统通常都围绕 EAP 运作。</p>
<p>EAP 与 MES 等其他系统间通讯采用 Tibco RV 协议、与机台设备间通讯采用 SECS/GEM 等等协议。</p>
<div class="mermaid" id="id-2"></div>
<h3 id="市场主要厂商">市场主要厂商</h3>
<p>前道 CIM：</p>
<ul>
<li>IBM（SiView）</li>
<li>应用材料（Applied Materials）（FAB300）</li>
</ul>
<p>MES：</p>
<ul>
<li>西门子（Siemens）</li>
<li>霍尼韦尔（Honeywell Forge）</li>
<li>艾默生（Emerson）</li>
<li>罗克韦尔（Rockwell Automation）</li>
<li>达索（Dassault）</li>
<li>ABB Ability</li>
</ul>
<p>YMS 多独立厂家，如 Synopsys（Synopsys Odyssey）。</p>
<p>后道封装：</p>
<ul>
<li>西门子（CAMSTAR、SIMATIC IT）</li>
</ul>
<h2 id="mes车间的头子">MES：「车间的头子」</h2>
<p>MES 上接计划层（如 ERP），下接一般控制层（如 EAP 或 <strong><ruby>SCADA<rt>监控与资料收集系统</rt></ruby></strong>），主要面向在现场一线操作的车间管理人员。实际上是多个模块集中呈现的平台，针对整个工厂，对稳定性要求较高。实际解决方案包括：</p>
<ul>
<li>计划排程管理</li>
<li><strong><ruby>PRP<rt>生产工艺流程</rt></ruby></strong>（Process Plan）：对生产的流程进行四层抽象（从单个 <strong><ruby>operation<rt>操作</rt></ruby></strong> 到连接成 <strong><ruby>stage<rt>步骤</rt></ruby></strong>，再连接为一个大的 <strong><ruby>layer<rt>层</rt></ruby></strong>，最后成为一条完整的 <strong><ruby>route<rt>路径</rt></ruby></strong>）</li>
<li><strong><ruby>WIP<rt>制品管理模块</rt></ruby></strong>（Wafer in Process）：创建批次、查询批次、报废批次等批次相关的处理</li>
<li>设备管理</li>
<li>数据管理</li>
<li>报表管理</li>
<li><strong><ruby>GUI<rt>图形界面设计</rt></ruby></strong>：包括面向生产线操作员和面向工艺工程师等不同界面</li>
</ul>
<h2 id="eap搜集信息传达指令">EAP：搜集信息、传达指令</h2>
<p>EAP 上接 MES，下接机台设备。MES 所管理的各项数据都来自 EAP。EAP 先搜集所有生产数据和机台状态数据，再经由特定通讯协议传送到 MES 数据库，MES 再借由数据分析监控设备和生产流程。其同时也是整个 CIM 中其他模块的数据源。</p>
<p>例如生产状态的变化：由 EAP <strong>告知</strong> MES 一批货物状态的变化，MES <strong>改变</strong>这批货物的状态。</p>
<div class="mermaid" id="id-3"></div>
<p>对比单纯进行数据采集和一定图形界面化呈现的 SCADA，EAP 能配合其他模块达到生产自动化的要求、作为管理平台、融合 <strong><ruby>BI<rt>商业智能</rt></ruby></strong>（business intelligence）分析。</p>
<h2 id="apc管控过程提升良率">APC：管控过程、提升良率</h2>
<p>半导体量产中，由于投资规模庞大，良率哪怕能做到 1% 的提升，都能带来非常可观的收益增加。APC 就是一种提升良率或产能的综合解决方案。一般包括 R2R、FDC、OEE。在制程执行时，期间存在各种影响因素导致量产出的晶圆存在差异，需要通过实时监控影响因素变化的参数来提升良率或产能，而这依赖于 APC 对数据的搜集，包括 <strong><ruby>DCU<rt>数据收集单元</rt></ruby></strong>（Data Collection Unit）主动收集的资料以及对其他系统（如 MES、PMS 等）资料的运用。</p>
<p>有关 APC 的更多信息，可<a href="http://franktsao.blogspot.com/2009/10/apc.html" target="_blank" rel="noopener noreffer">按此访问</a>鼎捷软件曹永诚所撰导论（2005 年 6 月，Blogspot 链接）。</p>
<h2 id="关于-amhs">关于 AMHS</h2>
<p>12 吋厂线的 RTD 多与 AMHS 搭配使用以达到更高程度的自动化，通常还与 <strong><ruby>MCS<rt>物料控制系统</rt></ruby></strong>（Material Control System） 一起运作。RTD 针对制程情况给出派货建议，未配备 AMHS 的工厂一般通过人工运输，配备 AMHS 则可以相互通讯以自动运输。AMHS 中各种器械有序灵活的运作，能让人直观感受到工业制造具备的魅力。一般包括：</p>
<ul>
<li><strong><ruby>OHT<rt>空中行走式/高架搬运系统</rt></ruby></strong>（Overhead Hoist Transfer），多用在加工区间内（Intra-bay），也可用于不同区间之间（Inter-bay）或覆盖全厂（factory wide）的运输。</li>
<li><strong><ruby>OHS<rt>空中行走式/高架搬运车</rt></ruby></strong>（Overhead Shuttle），常用于不同仓储设备间（也称 Inter-bay Transport System）。</li>
<li><strong><ruby>AGV<rt>自动导引车</rt></ruby></strong>（Automated Guided Vehicle），常用在复杂路径。</li>
<li><strong><ruby>RGV<rt>有轨导引车</rt></ruby></strong>（Rail Guided Vehicle），轨道运输，带机械臂。</li>
</ul>
<h2 id="半导体制作工序英文不完全对照">半导体制作工序：英文不完全对照</h2>
<div class="mermaid" id="id-4"></div>
]]></description>
</item><item>
    <title>C&#43;&#43; 模版类重载流输入输出运算符</title>
    <link>https://fanrongbin.com/cpp-template-friend/</link>
    <pubDate>Fri, 31 Dec 2021 22:48:59 &#43;0800</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/cpp-template-friend/</guid>
    <description><![CDATA[<p>在 C++ 中只能通过友元函数来重载流输入输出运算符 <code>&lt;&lt;</code> <code>&gt;&gt;</code>。由于搭配模板类的使用，编译器可能在对应编译友元函数时<strong>无法确定</strong>其为模版，需要事先声明。</p>
<h2 id="方法-1提前声明并使用--确认">方法 1：提前声明并使用 &lt;&gt; 确认</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//需要提前进行声明，以使类中对友元函数的声明进一步确认函数为模板函数
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">complex</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">newout</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">complex</span><span class="p">{</span> <span class="c1">//以复数类为例
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
  	<span class="n">A</span> <span class="n">real</span><span class="p">,</span> <span class="n">image</span><span class="p">;</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">complex</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">A</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">image</span><span class="p">(</span><span class="n">b</span><span class="p">){</span>
		<span class="p">}</span>

<span class="c1">//在运算符 &lt;&lt; 后加入 &lt;&gt; 以帮助编译器进一步确定该友元函数为模板函数
</span><span class="c1"></span>		<span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">newout</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> 
<span class="p">};</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">newout</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">){</span>
	<span class="n">newout</span><span class="o">&lt;&lt;</span><span class="s">&#34;(&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">real</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">image</span><span class="o">&lt;&lt;</span><span class="s">&#34;)&#34;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newout</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="方法-2在声明友元函数的同时定义友元函数">方法 2：在声明友元函数的同时定义友元函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">complex</span><span class="p">{</span>
	<span class="k">private</span><span class="o">:</span>
		<span class="n">A</span> <span class="n">real</span><span class="p">,</span> <span class="n">image</span><span class="p">;</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">complex</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">A</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">image</span><span class="p">(</span><span class="n">b</span><span class="p">){</span>
		<span class="p">}</span>

<span class="c1">//在声明友元函数的同时定义友元函数
</span><span class="c1"></span>		<span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">newout</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">){</span>
			<span class="n">newout</span><span class="o">&lt;&lt;</span><span class="s">&#34;(&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">real</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">image</span><span class="o">&lt;&lt;</span><span class="s">&#34;)&#34;</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">newout</span><span class="p">;</span>
		<span class="p">}</span>
<span class="p">};</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="如果可以不使用友元函数">如果可以不使用友元函数</h2>
<p>如果模板类中的成员为公有，则完全不需要在模板类中声明友元。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">complex</span><span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">A</span> <span class="n">real</span><span class="p">,</span> <span class="n">image</span><span class="p">;</span> <span class="c1">//成员为公有
</span><span class="c1"></span>		<span class="n">complex</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">A</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">image</span><span class="p">(</span><span class="n">b</span><span class="p">){</span>
		<span class="p">}</span>
<span class="c1">//		friend ostream &amp; operator &lt;&lt; &lt;&gt;(ostream &amp;newout, const complex&lt;A&gt; &amp;m);
</span><span class="c1">//友元在此是不必要的
</span><span class="c1"></span><span class="p">};</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">newout</span><span class="p">,</span> <span class="k">const</span> <span class="n">complex</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">){</span>
	<span class="n">newout</span><span class="o">&lt;&lt;</span><span class="s">&#34;(&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">real</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="o">&lt;&lt;</span><span class="n">m</span><span class="p">.</span><span class="n">image</span><span class="o">&lt;&lt;</span><span class="s">&#34;)&#34;</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">newout</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">complex</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://isocpp.org/wiki/faq/templates#template-friends" target="_blank" rel="noopener noreffer">Why do I get linker errors when I use template friends? - Standard C++</a></li>
</ul>
]]></description>
</item><item>
    <title>2021 年终：昨天一直是今天，就像今天一直是明天</title>
    <link>https://fanrongbin.com/yesterday-is-today-is-tomorrow/</link>
    <pubDate>Fri, 31 Dec 2021 20:51:59 &#43;0800</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/yesterday-is-today-is-tomorrow/</guid>
    <description><![CDATA[<p>我想了很久，因为两年过得像一年。翻了翻手机相册，还是放弃了理顺今年「所作所为」的念头，意义不大。明天开始的新一年，似乎也将和过去的十二个月，在巨大的混凝土运送车里保持匀速搅拌，作为一大团不至于凝固的泥巴。</p>
<p>已经对新冠脱敏，指不论是日增或新变种的消息，或者突然的封校封城，在生理和心理上不为所动。其实也不仅是疫情，整体上对很多事物都看开了很多，离开了很多过去被动或主动设下的困境，或者说从源头开始避免。现在常是这样的状态，在不相调和时，我先选择离开，停止消耗，这样才能更好地拥抱自己。</p>
<p>但这种改变的确是懦弱的、畏怯的，是不能也不值得美化的。总不是束手无策的，必须承认。</p>
<p>很恍然，对明年原来没有什么特别的期待，这样的一个好处是对目标和进度的把控拉得更近了，就像在触控板上将拇指和食指收拢再分开。还有是继续向内走。我觉得这个不仅仅是我，也是这两年之后许多人或多或少都会有的行动，面对自身的时间多了，出现从复杂往简单调转的诉求。另一个好处是停止对自己预期看涨，幻想多头，这个应该是影响最大的。</p>
<p>困扰我许久的那种感受，在接连读了项飙老师的访谈录《把自己作为方法》以及《正午故事 1》中另一篇对谈后有了新的把握，「悬浮」与「错置」，都在慢慢展开的脱敏中渐渐从裹挟里剥离。还有就是大概保持着每三个月跟家人吵一次架的频率，把话讲开了。</p>
<p>这么看来，今年的收获还挺大。</p>
<p>今年听到比较有启发的播客节目有《新闻实验室》关于非虚构写作的第 17 期（《正午故事》郭玉洁，端传媒张洁平）和第 19 期（《正面连接》梁鸣），以及《晚风说》智堡 Mikko 和 Yachak 来的两期。无意中发现的《暮酒朝谈》，也给我很多帮助。</p>
<p>今年听到最喜欢的新专辑有：Yu Su《Yellow River Blue》、Mndsgn《Rare Pleasure》、Daniel Avery《Together in Static》、Ultraísta《Sister》、hikaru yamada and metal casting jazz ensemble《moon》、李遐怡《4 ONLY》、Leon Bridges《Gold-Diggers Sound》、Tinashe《333》。</p>
<p class="right-date"  align="right">2021 年 12 月 31 日</p>
<hr>
<iframe src="https://embed.podcasts.apple.com/cn/podcast/%E6%9A%AE%E9%85%92%E6%9C%9D%E8%B0%88/id1521684443?itsct=podcast_box_player&amp;itscg=30200&amp;ls=1&amp;theme=auto" height="450px" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *;" style="width: 100%;  overflow: hidden; border-radius: 10px; background: transparent;"></iframe>
<hr>
<iframe allow="autoplay *; encrypted-media *; fullscreen *" frameborder="0" height="450" style="width:100%;overflow:hidden;background:transparent;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/album/yellow-river-blue/1546173813"></iframe>
<hr>
<blockquote>
<p>什么是蹲下起身时眼前的洁白，什么是动物园的房间。不当一切真的命中注定，指认所有被构造的一切，要声称自己是罪人，在跌落旧关卡时搜集证据。这会是水的流动，这会是卡在鞋底细缝中风干的叶片碎末，这会是酸胀的小腿和脉冲。这就是真的，这就是假的，这一直是一场戏，我一直在剧院里走走停停。很多个分成好几段陆续死去，有些是谋杀，有些是自杀，有些出于意外，一个死了，另一个被迫接着出现，不是任何人的错，新的来了。草丛里经常种下过去拯救自己的毒药，送给兔子，他们就能帮忙消化成脚印，铺在路上，以至于再试图向前爬去时，手指所沾上的只是兔子的粪便、毒药的沉淀，膝盖磨出来的血就不会看得见，路看上去也不会太远。以至于又是一种曼妙的错觉，支撑这生死的流变。</p>
<p class="right-date" align="right">2021 年 12 月 20 日</p>
</blockquote>
]]></description>
</item><item>
    <title>来自 Apple 的流媒体推广工具</title>
    <link>https://fanrongbin.com/apple-media-service-marketing/</link>
    <pubDate>Sat, 04 Dec 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/apple-media-service-marketing/</guid>
    <description><![CDATA[<p>Apple 分别在今年 9 月、去年 11 月和去年 7 月发布了用于 iOS 应用、播客和 Apple Music 推广的工具，以帮助开发者迅速创建赏心悦目、符合 Apple 设计规范的推广用图和网页内嵌模块。现在还包括 Arcade、News 和 TV，已经是完全搭建起整个适用于 Apple 媒体服务的推广工具平台。你可以<a href="https://tools.applemediaservices.com/" target="_blank" rel="noopener noreffer">按此访问 Apple Services Marketing Tools</a>。</p>
<p>和订阅制播客一并发布的还有 <a href="https://podcaster.apple.com/" target="_blank" rel="noopener noreffer">Apple Podcasts for Creators</a>，方便制作者查看收听数据等信息。</p>
<p>这里给出几个嵌入实例：</p>
<p>Apple Podcast：</p>
<iframe src="https://embed.podcasts.apple.com/us/podcast/%E4%BB%8E%E8%8F%9C%E8%A1%97%E5%88%B0%E5%8E%A8%E6%88%BF-07%E6%88%90%E5%B9%B4%E4%BA%BA%E7%9A%84%E6%88%90%E7%98%BE%E7%89%A9%E8%B4%A8-%E8%8C%B6%E5%92%8C%E5%92%96%E5%95%A1/id1585465479?i=1000537928836&amp;itsct=podcast_box_player&amp;itscg=30200&amp;ls=1&amp;theme=auto" height="175px" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *;" style="width: 100%; overflow: hidden; border-radius: 10px; background: transparent;"></iframe>
<p>实际上会自动判断访问者所在地区。例如这是一个未在中国大陆上架的播客，显示内容不可用。</p>
<iframe src="https://embed.podcasts.apple.com/us/podcast/fokcast-%E7%94%98%E7%A5%BA%E6%B5%81%E8%A1%8C-%E9%A6%99%E6%B8%AFpodcast/id1546976247?itsct=podcast_box_player&amp;itscg=30200&amp;ls=1&amp;theme=auto" height="450px" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *;" style="width: 100%; overflow: hidden; border-radius: 10px; background: transparent;"></iframe>
<p>Apple Music：</p>
<iframe src="https://embed.music.apple.com/us/album/tellusboutyourself/1543102982?app=music&amp;itsct=music_box_player&amp;itscg=30200&amp;ls=1" height="450px" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *;" style="width: 100%; overflow: hidden; border-radius: 10px; background: transparent;"></iframe>
<p>Apple TV：</p>
<iframe src="https://embed.tv.apple.com/us/show/snoopy-in-space-the-search-for-life/umc.cmc.12l86ri6vfjlimw2m8b8dzszs?itscg=30200&amp;itsct=tv_box_player" height="371px" frameborder="0" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *;" style="width: 100%; max-width: 660px; border-radius: 10px; background: transparent;"></iframe>
<p>Apple Store 推广用图：</p>

<p>挺好看的。</p>
]]></description>
</item><item>
    <title>C&#43;&#43; 中的拷贝构造函数：浅拷贝、深拷贝</title>
    <link>https://fanrongbin.com/cpp-copy-constructor/</link>
    <pubDate>Mon, 29 Nov 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/cpp-copy-constructor/</guid>
    <description><![CDATA[<h2 id="什么时候会调用拷贝构造函数">什么时候会调用拷贝构造函数</h2>
<ul>
<li>一个对象以<strong>值传递</strong>的方式<strong>传入函数体</strong></li>
<li>一个对象以<strong>值传递</strong>的方式<strong>从函数返回</strong></li>
<li>一个对象<strong>通过另一个对象</strong>以进行<strong>初始化</strong></li>
</ul>
<h2 id="默认拷贝构造函数浅拷贝">默认拷贝构造函数：浅拷贝</h2>
<p>即：将被拷贝对象的数据成员的值一一赋值给新创建的对象</p>
<ul>
<li>如果数据成员中有指针成员
<ul>
<li><strong>浅拷贝只是增加了一个指针指向已经存在的内存</strong></li>
<li>则<strong>新对象的指针所指向的地址</strong>与<strong>被拷贝对象的指针所指向的地址</strong>相同</li>
<li>则析构 delete 对象时会重复 delete 两次同一个内存空间而出错</li>
</ul>
</li>
</ul>
<h3 id="实例">实例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rect</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="c1">// 一指针成员
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="n">Rect</span><span class="p">(){</span>      <span class="c1">// 构造函数，p 指向堆中分配的一内存
</span><span class="c1"></span>        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// new 动态分配
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">(){</span>     <span class="c1">// 析构函数，释放动态分配的内存
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// delete 释放 p 所指向的内存
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>   <span class="c1">// 拷贝 rect1 来构造 rect2
</span><span class="c1"></span>		<span class="c1">// 也即： Rect rect2 = rect1;
</span><span class="c1"></span>		<span class="c1">// 浅拷贝，将成员的值进行拷贝 rect2.p = rect1.p （地址 = 地址）
</span><span class="c1"></span>
		<span class="c1">// 会出现错误
</span><span class="c1"></span>		<span class="c1">// 在 delete 时既要 delete rect2.p 指向的空间，又要 delete rect1.p 指向的内存。但这是同一个内存（地址 = 地址），导致同一个内存被释放两次
</span><span class="c1"></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同时还造成另外两个错误：</p>
<ul>
<li><code>rect2.p</code> 在初始化时新建的 <code>p</code> 所指向的内存没被释放（因为构造函数新建之后，又直接值传递换了地址），造成内存泄漏</li>
<li><code>rect2.p</code>（指针） 和 <code>rect1.p</code>（指针）指向同一块内存（同一个地址），任何一方的变动都会影响另一方</li>
</ul>
<h2 id="自行新建拷贝构造函数并使用深拷贝">自行新建拷贝构造函数：并使用深拷贝</h2>
<p>新增加一个指针，并申请一个新的内存。新指针指向新内存。</p>
<h3 id="实例-1">实例</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rect</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>			<span class="c1">// 一指针成员
</span><span class="c1"></span>    <span class="n">Rect</span><span class="p">(){</span>     <span class="c1">// 构造函数，p指向堆中分配的一内存
</span><span class="c1"></span>        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">){</span> <span class="c1">// 自行新建拷贝构造函数
</span><span class="c1"></span>        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>     <span class="c1">// 为新对象重新动态分配内存
</span><span class="c1"></span>        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
        <span class="c1">// 或带括号 *p = *(r.p);
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">(){</span>    <span class="c1">// 析构函数，释放动态分配的内存
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>		<span class="c1">// 拷贝 rect1 来构造 rect2
</span><span class="c1"></span>		<span class="c1">// 也即： Rect rect2 = rect1;
</span><span class="c1"></span>    <span class="c1">// 深拷贝，创建新的 p 以及其所指向的空间，然后把值赋过去 *r.p = *rect1.p; 然后 *rect2.p = *r.p;
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不妨输出地址比对一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rect</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">Rect</span><span class="p">(){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;start new: &#34;</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 无参的新构造（初始化）时创建的内存空间
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">Rect</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;copy: &#34;</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 			<span class="c1">// 拷贝构造时创建的内存空间
</span><span class="c1"></span>        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Rect</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;de: &#34;</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 		<span class="c1">// 所析构掉的内存空间
</span><span class="c1"></span>            <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Rect</span> <span class="n">rect1</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">rect1</span><span class="p">.</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">// rect1.p 指向的内存空间
</span><span class="c1"></span>    <span class="n">Rect</span> <span class="n">rect2</span><span class="p">(</span><span class="n">rect1</span><span class="p">);</span>			<span class="c1">// 拷贝 rect1 来构造 rect2
</span><span class="c1"></span>    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">rect2</span><span class="p">.</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">// rect2.p 指向的内存空间
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出得：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">start new: 0x10582d930
0x10582d930
copy: 0x10582f220
0x10582f220
de: 0x10582f220
de: 0x10582d930
Program ended with <span class="nb">exit</span> code: <span class="m">0</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://blog.csdn.net/xunye_dream/article/details/77547438" target="_blank" rel="noopener noreffer">C语言中的位拷贝与值拷贝浅谈 - CSDN</a></li>
<li><a href="https://blog.csdn.net/lwbeyond/article/details/6202256" target="_blank" rel="noopener noreffer">C++拷贝构造函数详解 - CSDN</a></li>
</ul>
]]></description>
</item><item>
    <title>使用 matplotlib 遇到的几个问题</title>
    <link>https://fanrongbin.com/november-matplotlib/</link>
    <pubDate>Fri, 12 Nov 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/november-matplotlib/</guid>
    <description><![CDATA[<p>这周在用 matplotlib 画几张图。数据 csv 下载自 ECBStat 和 FRED。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">plt</span>
</code></pre></td></tr></table>
</div>
</div><p>首先是解决字符串转日期型的问题。<strong>我希望将日期作为横轴，而且显示合理。</strong></p>
<p>使用 <code>datetime</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">example</span><span class="o">.</span><span class="n">date</span>

<span class="c1"># example.date 是我的 example.csv 文件中日期对应列。</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>更多时间处理参数，详见下方链接。</p>
<p>自动格式化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">autofmt_xdate</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://docs.python.org/zh-cn/3/library/datetime.html" target="_blank" rel="noopener noreffer">datetime - Python 3 中文文档</a></li>
<li><a href="https://blog.csdn.net/gty931008/article/details/80254806" target="_blank" rel="noopener noreffer">python之时间、日期处理模块（datetime）- CSDN</a></li>
</ul>
<p><strong>我希望定位一个具体日期，并用竖线标识。</strong> 这里用到<code>pandas</code>把我希望的具体日期转为时间戳。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;2014-06-30&#39;</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#000&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axvline.html" target="_blank" rel="noopener noreffer">matplotlib.pyplot.axvline</a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timestamp.html" target="_blank" rel="noopener noreffer">pandas.Timestamp</a></li>
</ul>
<p></p>
<p><strong>我希望在一张图（单个文件）中同时展示多个图表</strong>，既可以用 <code>subplot</code>，也可以用 <code>GridSpec</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">totalb</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">conb</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>也可以：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="n">plt</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wspace</span><span class="o">=</span><span class="mf">.25</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">.25</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">totalb</span><span class="p">)</span>

<span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">conb</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如何定义具体位置或查看更多实例，请见 <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplot.html?" target="_blank" rel="noopener noreffer">matplotlib.pyplot.subplot</a> 和 <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.gridspec.GridSpec.html#matplotlib.gridspec.GridSpec" target="_blank" rel="noopener noreffer">matplotlib.gridspec.GridSpec</a>。</p>
<p></p>
<p></p>
<p>参考了实例 <a href="https://matplotlib.org/stable/gallery/subplots_axes_and_figures/axes_zoom_effect.html" target="_blank" rel="noopener noreffer">Axes Zoom Effect</a>。</p>
]]></description>
</item><item>
    <title>eclipse, indices / indexes 与股价指数</title>
    <link>https://fanrongbin.com/eclipse-indices-indexes/</link>
    <pubDate>Tue, 02 Nov 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/eclipse-indices-indexes/</guid>
    <description><![CDATA[<p>北京时间今天早上的一则新闻：</p>
<blockquote>
<p>Nov 1 (Reuters) - Wall Street&rsquo;s main <strong>indexes</strong> notched record closing highs on Monday as Tesla shares surged and the energy sector gained while investors looked ahead to a major Federal Reserve meeting later in the week.</p>
<p>The Dow Jones Industrial Average (.DJI) <strong>eclipsed</strong> 36,000 points for the first time ever during intraday trading, ending just shy of that level.</p>
<p><a href="https://www.reuters.com/business/wall-street-hits-records-tesla-surges-focus-fed-meeting-2021-11-01/" target="_blank" rel="noopener noreffer">Reuters</a></p>
</blockquote>
<h2 id="eclipse">eclipse?</h2>
<p>eclipse 作动词除了天文上「遮住⋯⋯的光」即「食」（日食、月食）的意思、比较文学性的「使⋯⋯黯淡无光/黯然失色」的意思之外，还可以如引用所指，在商务英语中，表示在数量上或级别上「超过、高过」的意思。</p>
<p>下引剑桥词典：</p>
<blockquote>
<p><strong>to become greater in amount or level than something else:</strong></p>
<p><em>The increased consumer spending from new businesses has already helped shopping, dining, and real estate <strong>eclipse</strong> oil revenues.</em></p>
<p><em>Their stock is up 50% so far this year, as their profit growth is expected to <strong>eclipse</strong> that of larger companies.</em></p>
<p>(Definition of eclipse from <a href="https://dictionary.cambridge.org/dictionary/english/eclipse" target="_blank" rel="noopener noreffer">the Cambridge Business English Dictionary</a> © Cambridge University Press)</p>
</blockquote>
<h2 id="indices-或-indexes">indices 或 indexes?</h2>
<p>都可以，它们都是 index 的复数形式。indices 经常出现在在数学、统计学、金融学、科学等相关文章中，书面也经常用。北美用 indexes 更多，其他英语国家用 indices 更多。</p>
<h2 id="股票价格指数">股票价格指数</h2>
<p>股票价格指数（Stock Price Index）也即股票指数。其制定，以方便投资者了解多只股票价格的波动，进而也能反应市场的态势。进一步也能体现政治、社会的发展形势。</p>
<p>有多种编制方式：</p>
<h3 id="按覆盖范围分">按覆盖范围分：</h3>
<ul>
<li><strong>宽基指数</strong>（广基指数）（broad-based indices）
<ul>
<li>沪深 300，中证 500</li>
<li>道琼斯工业指数</li>
<li>标准普尔 500 指数</li>
</ul>
</li>
<li><strong>窄基指数</strong>（narrow-based indices）（行业/主题指数）
<ul>
<li>万得能源指数</li>
<li>台湾 50 指数</li>
<li>摩根士丹利生物技术指数</li>
</ul>
</li>
</ul>
<h3 id="按计算方式分不全">按计算方式分：（不全）</h3>
<ul>
<li>
<p><strong>价格加权指数</strong>（Price Weighting based indices）</p>
<p>成分股股价的简单算术平均。</p>
<ul>
<li>道琼斯工业指数</li>
<li>纽约证交所科技 100 指数</li>
<li>日经 225 指数（日经平均指数）</li>
</ul>
</li>
<li>
<p><strong>市值/股本/资本加权指数</strong>（Market-Capitalisation Weighting based indices）</p>
<p>给予的权重基于该股票<strong>市值</strong>在整个<strong>组合市值</strong>中的权重。</p>
<ul>
<li>中证 500 指数</li>
<li>标准普尔 500 指数</li>
<li>香港恒生指数</li>
</ul>
</li>
<li>
<p><strong>自由流通市值/股本加权指数</strong>（Free-float adjusted Market-Capitalisation Weighting based indices）</p>
<p>类似市值加权。但这里的市值使用流通市值，即可供公众交易的部分。</p>
<ul>
<li>沪深 300 指数</li>
</ul>
</li>
<li>
<p><strong>等权重加权指数（无权重指数）</strong>（Equal Weighting based indices）</p>
<p>给予所有的成分股票以相同的权重，即假设每只成分股都购买了相同的金额。</p>
<ul>
<li>巴伦 400 指数</li>
<li>标普 500 等权重指数</li>
</ul>
</li>
<li>
<p><strong>基本面加权指数</strong>（Fundamentally based indices）</p>
<p>通常以公司的基本面（销售收入、现金流、分红等）为基础来分配个股的权重。</p>
<ul>
<li>上证 380 基本面加权指数</li>
<li>富时 RAFI 指数系列</li>
</ul>
</li>
<li>
<p><strong>因子指数</strong>（Factor Weighting based indices）</p>
<p>用以反映特定因子特性的绩效。（如股票价值、企业质量、红利、风险等）</p>
<ul>
<li>富时环球因子指数系列</li>
<li>标普中国 A 股低波红利指数</li>
</ul>
</li>
<li>
<p><strong>波动率加权指数</strong>（Volatility Weighting based indices）</p>
<ul>
<li>芝加哥期权交易所市场波动率指数（恐慌指数 CBOE Volatility Index, ^VIX）</li>
</ul>
</li>
<li>
<p><strong>最小方差指数</strong>（Minimum Variance Weighting based indices）</p>
<p>以实现组合方差最小化为目标的指数。</p>
<ul>
<li>斯托克全球 1800 最小方差指数</li>
</ul>
</li>
</ul>
<h3 id="比较有代表性的指数">比较有代表性的指数</h3>
<h4 id="按地域">按地域</h4>
<ul>
<li>美国
<ul>
<li>标准普尔 500 指数（S&amp;P 500, ^GSPC）</li>
<li>道琼斯工业指数（Dow 30, ^DJI）</li>
<li>纳斯达克综合指数（Nasdaq, ^IXIC）</li>
</ul>
</li>
<li>亚洲
<ul>
<li>日经 225 指数（Nikkei 225, ^N225）</li>
<li>香港恒生指数（HANG SENG INDEX, ^HSI）</li>
<li>韩国综合股价指数（KOSPI Composite Index, ^KS11）</li>
<li>上证综合指数（SSE Composite Index, 000001.SS）</li>
<li>深证成份股指数（Shenzhen Component, 399001.SZ）</li>
</ul>
</li>
<li>欧洲
<ul>
<li>英国富时 100 指数（FTSE 100, ^FTSE）</li>
<li>法国 CAC 40 指数（CAC 40, ^FCHI）</li>
<li>德国 DAX 30 指数（DAX PERFORMANCE-INDEX, ^GDAXI）</li>
<li>欧洲斯托克 50 指数（ESTX 50 PR.EUR, ^STOXX50E）</li>
</ul>
</li>
</ul>
]]></description>
</item><item>
    <title>Engadget 简体中文版关闭</title>
    <link>https://fanrongbin.com/engadget-cn-closed/</link>
    <pubDate>Tue, 02 Nov 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/engadget-cn-closed/</guid>
    <description><![CDATA[<blockquote>
<p>2021 年 11 月 1 日起，用户无法从中国大陆使用 Yahoo 的产品与服务。这并不影响 Yahoo 在全球其他地方的产品及服务。</p>
<p>Yahoo 中国</p>
</blockquote>
<p>同时，Yahoo Weather（雅虎天气）宣布停止中国大陆服务，Engadget 简体中文版亦宣布停止更新。</p>
<p></p>
<p>Engadget 简体中文版（瘾科技）于 2005 年 10 月 1 日正式开站，触角广泛，文字亦精炼扼要。记得最初是在 Flipboard 或者 Zaker 上偶然订阅了 Engadget 中文版，它是我所接触到的第一个科技资讯媒体。后来陆陆续续地还订阅了 The Verge、TechCrunch，还有 LiveSino、月光博客。它们构成我的很多回忆。中间编辑团队一度更换，希望了解更多的话，可见文末。</p>
<p>现在的话，新资讯有赖于 Telegram 上的几个频道推送通知，产品测评的话看 YouTube 多一点（Dave2D、TESTV 等等），市场新闻、创投等也有比较集中的信源了。</p>
<p>关于团队更换：</p>
<ul>
<li><a href="https://chinese.engadget.com/chinese-2011-06-27-new-engadget-chinese.html" target="_blank" rel="noopener noreffer">《歡迎來到全新的 Engadget 中文版》</a> - Richard Lai@Engadget</li>
<li><a href="http://yblog.org/archive/index.php/aol_relocate_engadget_chinese_201106" target="_blank" rel="noopener noreffer">《Engadget 中文版與癮科技拆夥的可能內幕》</a>- 永遠的真田幸村</li>
</ul>
<p>祝新老成员未来都好。</p>
<p>正式开站纪念博文存档：</p>
<p></p>
]]></description>
</item><item>
    <title>QDII 与 QDII 基金买卖</title>
    <link>https://fanrongbin.com/qdii/</link>
    <pubDate>Sun, 31 Oct 2021 00:00:00 &#43;0000</pubDate><author>
        <name>FAN Rongbin</name>
    </author><guid>https://fanrongbin.com/qdii/</guid>
    <description><![CDATA[<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>更新时间<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">本文最后一次更新于 2021 年 10 月 31 日。在<strong>政策</strong>等方面可能有所变化，请知悉。</div>
        </div>
    </div>
<p>现<strong>中国大陆境内向境外</strong>进行合法投资（除境外直接投资 ODI、陆股通）的三种形式：</p>
<p></p>
<p>而<strong>境外向境内</strong>进行投资，可分直接投资和间接投资。QFII 和 RQFII 属于外资直接投资境内证券二级市场。其包括股息及买卖价差等在内的各种资本所得，经审核后可转换为外汇汇出。实际为对外资有限度地开放境内的证券市场。</p>
<p></p>
<p></p>
<p>QDII 基金，即从事境外证券市场的股票、债券等有价证券业务的证券投资基金。也就是 QDII 中合格的基金公司以设立基金的方式进行募资，进而在境外投资。</p>
<p>在国内购买 QDII 基金的目的，主要在于分散单一市场可能的风险。</p>
<h2 id="主要子分类">主要子分类</h2>
<ul>
<li>主动股票型</li>
<li>指数型</li>
<li>债券型</li>
<li>混合型</li>
<li>另类投资型
<ul>
<li>大宗商品型</li>
<li>房地产信托型 REITs</li>
<li>绝对收益型</li>
<li>资产配置型 FOF</li>
</ul>
</li>
</ul>
<h2 id="t2-交易规则">T+2 交易规则</h2>
<p>只投资港股的 QDII 基金遵循 T+1 交易规则，包括美股的 QDII 基金遵循 T+2 交易规则。</p>
<p>美股交易时间（除节假日等休市日）：</p>
<p></p>
<p>而 QDII 基金遵循国内交易时间（除节假日等休市日）：即周一至周五 9:30-11:30，13:00-15:00。</p>
<p><strong>境内外</strong>节假日休市都暂停申购、赎回。</p>
<p><strong>买入延迟</strong>：在国内交易时间买入，需要等美股收盘后（第二天）按其收盘价计算买入份额。</p>
<p><strong>基金净值更新延迟</strong>：美股凌晨收盘后，可见预估净值，但最终净值需待基金公司核准确认。但美股此时（第二天国内交易时间范围内）未开盘交易，无法计算净值，只能等第三天美股收盘后确认最终净值，确认买入份额。</p>
<p>相应地，<strong>份额更新延迟</strong>，<strong>收益更新延迟</strong>。</p>
<blockquote>
<p>在 2021 年 10 月 25 日周一 14:00（第一天盘前或交易时间内）买入某 QDII 基金，以 10 月 26 日周二 4:00（第二天）美股收盘价计算买入份额，在 10 月 27 日周三（第三天）更新净值，确认买入份额。在 10 月 28 日周四（第四天）可查看 T+1 日收益。赎回同理。
实际在周一看到的净值，是根据周日的行情。</p>
</blockquote>
<h2 id="低门槛高费率">低门槛、高费率</h2>
<p>通常 10 元起即可申购。</p>
<p>费率主要表现在<strong>管理费率</strong>上。</p>
<h2 id="风险">风险</h2>
<h3 id="交易风险">交易风险</h3>
<p>隔日计算，无法预知第二天的大盘情况。</p>
<h3 id="汇率风险">汇率风险</h3>
<p>情形：人民币兑美元贬值（又或美元自身走强），配置美元资产的 QDII 基金获得收益增强。</p>
<h3 id="流动性风险">流动性风险</h3>
<ul>
<li>情形 1：QDII 基金申购踊跃，其本身因额度限制而暂停申购。</li>
<li>情形 2：美股节假日休市，亦无法申购赎回。</li>
<li>情形 3：未开放二级市场交易的某 QDII 基金，从赎回到到账需约 8-10 个工作日。</li>
</ul>
]]></description>
</item></channel>
</rss>
